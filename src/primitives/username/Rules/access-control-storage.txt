Primitives and rules have an access control contract to limit who can perform certain functions, like configuration, etc.

Primitive's access control and Rule's access control are not necesarilly shared, as they are in different contract storages.
However, the same access control contract address can be set for both Primitive and its Rules if desired.

Rules can be set on primitives either directly (a standalone rule contract, or a upgradable proxy) or through a Rule Combinator.
Thus, there are three possible ways to initialize the access control for a rule:
    /**
     * Option #1: Rule is used directly as a standalone contract.
     *      - Access control should be set in the constructor().
     * Option #2: Rule is used directly as a UUPS, Transparent or Beacon proxy.
     *      - Access control set through initialize() function.
     * Option #3: Rule is used via a RuleCombinator (which is like a proxy too).
     *      - Access control set in the RuleCombinator contract itself via configure() function.
     */

When using a Rule Combinator, because inner rules will be called through DELEGATECALL, the access control will be shared between rules.

We introduce the following `initialize` function as well as a constructor parameter to allow
standalone rules (rules that are set on the primitive directly instead of using a RuleCombinator) to work properly too:

    // Use constructor if the rule is set directly
    constructor(IAccessControl accessControl) {
        IMPLEMENTATION = address(this);
        // Initialize the access control. If this will be used with a proxy, we suggest to pass address(0) in impl.
        _accessControl = accessControl;
    }

    // We need this function for the Option #2: Proxy.
    function initiliaze(IAccessControl accessControl) external {
        // TODO: This should be read from the "lens.username.accessControl" slot
        require(address(_accessControl) == address(0), 'UsernameCharsetRule: Already initialized');
        _accessControl = accessControl;
    }
