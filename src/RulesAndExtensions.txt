QUESTION: Why don't we give full permissions to the extension, and why don't we allow only one extension.
Then, we instead of allowing msg.sender OR extension, we check for extension, and ONLY if it is not set, we allow
msg.sender to call directly. THIS feels like a proper extension, because setting THE extension REALLY OVERRIDES the
underlying primitve, making it irrelevant without its extension. Basically, extension is always forced to be the entry-point.

Optionally we could let the pirmitive be the entry point, and DELEGATECALL to the extension instead of using its own logic.

WHY THE NEED OF MULTIPLE EXTENSIONS?

1 - It extends the base behaviour in a way that requires SuperUser permissions to do so.

2 - Global rules, apply to all users + control over the local rules setup

3 - Local rules setup for each user

------------------------------------------------------------------------------------------------------------------------

Global Rules => Primitive Rule
Local Rules => Some entity rule

Example Follow Graph:
[GLOBAL] In the Follow Graph => Follow Rules
[LOCAL] In the Follow Graph => Graph Rules

Example Feed:
[GLOBAL] In the Feed => Feed Rules
[LOCAL] In the Feed => Post/Reference Rules

------------------------------------------------------------------------------------------------------------------------

Classic notation: (c1 OR c2) AND c3

Polish notation: AND OR C1 C2 C3

struct PNInput {
    type: uint8, => OP = 0, ADDR = 1
    value: uint20 => if type == OP, value 0 == OR, 1 == AND; else if type == ADDR, value is address(value)
}

[PNInput(OP, AND), PNInput(OP, OR), PNInput(ADDR, 0), PNInput(ADDR, 1), PNInput(ADDR, 2)]

-----------

OR_rules = [[addy_o0, addy_o1, ..., addy_oN], ...]

rules = [addy_a0, addy_a1, ..., addy_aM] => [[addy_a0, addy_o0], [addy_a1], ..., [addy_aM]]
// switch: are these AND_OR, or OR_AND
// negate: you could somehow have an easy way to negate

AND_rules are chained with an AND with the OR_rules... (see below):

FINAL_STATEMENT = (addy_o0 OR addy_o1 OR ... OR addy_oN) AND (addy_a0 AND addy_a1 AND ... AND addy_aM)

1. Do we short-circuit??? => YES
This means, if you need to do something always, just put it into the AND_rules, and make sure it cannot revert when going through it

2. It's kinda ok... but not super powerful? Like what about: (addy1 OR addy2) AND (addy3 OR addy4)

"be part of this community" OR "be approved by the community to post once (like a DAO)"
AND
"pay the mandatory fee (which everyone should pay to post in this feed)" OR "own special NFT"

-------------

What I don't like about the approach of chaining contract calls, is that there is a lot of risk of losing state.

Because state might be held by the contracts you compose. So wanting to do a tweak into the rules of one contract,
could require to replace it, and then lose its previous state.

Solution: DELEGATE_CALL
Yes, but then it's kind of what I was saying before, we should use the diamond storage, and ALL devs should be careful
with the name conventions thy use, and make sure to collide only when they are actually talking about the same slot.
Like, don't use keccak("eipblahblah.storage.balance") unless you really know that this is a shared balance slot.
PROS: it's the same as in-place combined contracts, but without dealing with upgradability, just plug-in and off contracts.
CONS:
1.  you can collide storage and fuck it up, but it seems this also is a "CONS" present in the in-place inheritance approach.
2.  extra gas cost of delegate-calling other contracts, instead of just GOTO/JUMP to the internal function.

====================

We have three types of Extensibility features in every primitive (not all of them make sense in all the primitives, but bear with us):
- Extensions (through Permission overrides set by the owner of the primitive):
  - These override the msg.sender, so you can do something on someone elses behalf (like an admin/superuser/owner)
  - This is helpful with tokenization, cause the ERC-721 contract can then delete things when the NFT is burned, for example
- Global Rules (set by the owner of the primitive)
  - These are rules or hooks that are invoked and checked on every function of the primitive
  - For example: "a requirement to pay" rule can be set on "Join Community" function
  - Or: "AAVE Deposit" hook can be set on a paid "Post" function
  - These rules/hooks restrict or just hook another contract into the function, but they cannot override the permissions like the Extensions do
- Individual Rules (applied by the user to the item of the primitive (like to a post, or to anyone following this user))
  - User can set FollowModule rule for his follows on a FollowGraph primitive, so anyone who wants to follow him must pay or hold an NFT
  - User can set a ReferenceModule rule on a post of Feeds primitive, so anyone who wants to comment on his post must be his friend or pay
  - These rules or hooks are applied only to the particular user (or particular item)
  - Such Rules modules can also be whitelisted by the primitive owner using Global Rules (so for example owner can allow to use only "pay to follow" rule, and nothing else)

Examples:

Follows
-------
[✅] Extensions (through Permissions that FollowGraph owner chooses)
    - Tokenizing follows through ERC-721 (right to follow with this follow ID)
[✅] Global Rules (FollowGraph owner sets these)
    - Global follow modules that apply to everyone without their conscent lol
[✅] Individual Rules (user chooses to apply when anyone wants to following him)
    - Personal FollowModules are additional rules an indivual might add for following himself
      but these modules could be whitelisted by a global rule (e.g. whitelisted individual rules only!)

Feeds
-----
[✅] Extensions (through Permissions that a Feed owner chooses)
    - Admins and extra permissions: admins/mods can delete/edit posts of others overriding the ownership
    - (super weird but...) Each day one user can post on behalf of another he chooses (like a weird game)
    - Checks to allow multiple-authors (or should be global rule?)
    - Renting post space - like pay me to post 3 times on my behalf, expires after 24 hours
    - Tokenize post ownership as ERC-721 (right to edit/delete)
[✅] Global Rules (Feed owner sets these)
    - Pay to post in this feed
    - Only members of a community X can post
    - You can only post once a day
    - You can only post if you have a special NFT
[✅] Individual Rules (user chooses to apply when someone interacts with his post - someone comments, does a mirror, etc)
    - Reference modules (also can be whitelisted by global rule)

Communities
-----------
[] Extensions (through Permissions that a Community owner chooses)
    - Tokenize membership as ERC-721
    - Admins and extra permissions: admins/mods can delete/edit members
[✅] Global Rules (Community owner sets these)
    - Pay to join/kick
    - Admin approval to join/kick
    - Hold an NFT to join/kick
    - Current members vote as DAO to allow a new member
[❌] Individual Rules (user chooses to apply to his membership in the community?)
    - No use-case found so far...

Usernames
---------
[✅] Extensions (through Permissions that a Namespace owner chooses)
    - Tokenize hadles as ERC-721
[✅] Global Rules (Namespace owner sets these)
    - Charsets
    - Length
    - Pay to mint
[❌] Individual Rules (user chooses to apply when someone else wants to... do something with their username?)
    - No use-case found so far...

------------------------------------------------------------------------------------------------------------------------

Kimmo@ORB

Communities:
------------
  "put my membership on hold (pause), maybe even "upgrade or stake my membership". delegate my community voting rights to XYZ."

- "Leaving the community temporarily" without losing the membership rights (maybe you paid for it, or you did some crazy challenges to get it)
  * Why do you want to leave it in the first place (even temporarily)?
- Subscription-based Community membership (pay every month or lose membership). So if you "pause" you don't pay but you don't lose the place.
  * Why do you want to pause it in the first place?

- Different tiers of memberships, which can be upgraded or downgraded

- Members can participate in Community Voting
  * The voting is not part of the Community Primitive, but rather a separate contract on the side, which just checks isMember(account) when voting
  * It can also have a Delegation feature, where Members of the community can delegate their votes, and it will check for isDelegated(account) when voting instead

Usernames/Profiles:

  "I'm thinking here of a company account. Wouldn't it be better, to "allow" username to be shared across profiles for specific cases rather than accounts. I don't want my intern to access my money to collect things, but I want to have the intern to spend money on collecting."

Translation to human:
  I want intern to be able to collect things from company profile, but not to spend company money on collecting.
    * Technically this is a Profile Manager without rights to spend money, but with rights to collect things.

LensAccount (which has some money probably?)
  - Account Manager: Intern (who CanCollect, but cannot Spend LensAccount Money)

1) InternEOA makes an approval to CompanyAccount
2) InternEOA does a transaction to CompanyAccount to Collect shit for money
3) CompanyAccount should take InternEOA's money and make an approval to Collect for the same amount?
    a) How do we know this from CompanyAccount?
    b) Do we pass it in the data or smth?
4) CompanyAccount approves money to Collect shit
5) CompanyAccount calls CollectShit to Collect shit
6) CollectShit grabs the money from CompanyAccount and mints the Collect
7) Collect goes to....?
    a) Who?
    b) Intern specifies this? Or what?

FINAL BOSS QUESTION: How can we protect the CompanyAccount from Intern not giving it money, and just calling the Collect with Approval?
